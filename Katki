import pygame
import sys
import math
import time
from typing import List, Tuple
import random
import math

# Initialize Pygame
pygame.init()
sys.setrecursionlimit(2000)

# Constants
WINDOW_WIDTH = 700
WINDOW_HEIGHT = 700
GRID_COLS = 9
GRID_ROWS = 9
CELL_SIZE = min(WINDOW_WIDTH // GRID_COLS, WINDOW_HEIGHT // GRID_ROWS)
DOT_RADIUS = CELL_SIZE // 6
SHAKE_AMPLITUDE = 3
SHAKE_SPEED = 10
HQ_HEALTH = 5
RED_HQ_POS = (0, GRID_COLS // 2)  # Top middle
BLUE_HQ_POS = (GRID_ROWS - 1, GRID_COLS // 2)  # Bottom middle
POWERUP_INTERVAL_MIN = 5
POWERUP_INTERVAL_MAX = 7
STAR_SPIN_SPEED = 5
SQUARE_SPIN_SPEED = 3

# Colors
BLACK = (0, 0, 0)
RED = (153, 0, 0)
BLUE = (0, 153, 180)
PASTEL_RED = (255, 204, 204)
PASTEL_BLUE = (204, 255, 255)
GRAY = (200, 200, 200)

# Create the window
WINDOW = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))
pygame.display.set_caption("Ahelreaktsioon")

class Cell:
    def __init__(self):
        self.dots = 0
        self.color = None
        
    def is_empty(self) -> bool:
        return self.dots == 0
    
    def add_dot(self, color: Tuple[int, int, int]):
        self.dots += 1
        self.color = color
        
    def clear(self):
        self.dots = 0
        self.color = None

class HQCell(Cell):
    def __init__(self, color, health):
        super().__init__()
        self.color = color
        self.health = health
        self.dots = 0  # Always keep dots at 0
        
    def is_empty(self) -> bool:
        return False
        
    def clear(self):
        pass  # HQ cells can't be cleared
        
    def add_dot(self, color):
        pass  # HQ cells don't accumulate dots

class PowerupType:
    STAR = 'star'
    SQUARE = 'square'

class Powerup:
    def __init__(self, type, row, col):
        self.type = type
        self.row = row
        self.col = col
        self.angle = 0
        self.active = True

class DotFactory:
    def __init__(self, row, col, color):
        self.row = row
        self.col = col
        self.color = color
        self.angle = 0
        
class Game:
    def __init__(self):
        self.grid = [[Cell() for _ in range(GRID_COLS)] for _ in range(GRID_ROWS)]
        self.current_player = RED
        self.game_over = False
        self.winner = None
        self.turns_played = 0
        self.red_hq_health = HQ_HEALTH
        self.blue_hq_health = HQ_HEALTH
        
        red_row, red_col = RED_HQ_POS
        blue_row, blue_col = BLUE_HQ_POS
        self.grid[red_row][red_col] = HQCell(RED, self.red_hq_health)
        self.grid[blue_row][blue_col] = HQCell(BLUE, self.blue_hq_health)
        self.powerups = []
        self.dot_factories = []
        self.turns_until_powerup = random.randint(POWERUP_INTERVAL_MIN, POWERUP_INTERVAL_MAX)
        
    def get_all_neighbors(self, row: int, col: int) -> List[Tuple[int, int]]:
        neighbors = []
        for dr in [-1, 0, 1]:
            for dc in [-1, 0, 1]:
                if dr == 0 and dc == 0:
                    continue
                new_row, new_col = row + dr, col + dc
                if 0 <= new_row < GRID_ROWS and 0 <= new_col < GRID_COLS:
                    neighbors.append((new_row, new_col))
        return neighbors
    
    def get_empty_cells_without_neighbors(self):
        empty_cells = []
        for row in range(GRID_ROWS):
            for col in range(GRID_COLS):
                if self.grid[row][col].is_empty() and \
                   not any(p.row == row and p.col == col for p in self.powerups) and \
                   (row, col) not in [RED_HQ_POS, BLUE_HQ_POS]:
                    has_neighbor = False
                    for n_row, n_col in self.get_all_neighbors(row, col):
                        if not self.grid[n_row][n_col].is_empty():
                            has_neighbor = True
                            break
                    if not has_neighbor:
                        empty_cells.append((row, col))
        return empty_cells

    def spawn_powerup(self):
        empty_cells = self.get_empty_cells_without_neighbors()
        print("done")
        if empty_cells:
            row, col = random.choice(empty_cells)
            powerup_type = random.choice([PowerupType.STAR, PowerupType.SQUARE])
            self.powerups.append(Powerup(powerup_type, row, col))
            self.turns_until_powerup = random.randint(POWERUP_INTERVAL_MIN, POWERUP_INTERVAL_MAX)

    def activate_star_powerup(self, row, col, color):
        # Affect all cells in the same row and column
        moving_blobs = []
        for r in range(GRID_ROWS):
            if r != row and not isinstance(self.grid[r][col], HQCell):
                start_pos = (col * CELL_SIZE + CELL_SIZE // 2, row * CELL_SIZE + CELL_SIZE // 2)
                end_pos = (col * CELL_SIZE + CELL_SIZE // 2, r * CELL_SIZE + CELL_SIZE // 2)
                moving_blobs.append(MovingBlob(start_pos, end_pos, color, time.time(), duration=0.5))
                self.grid[r][col].color = color
                self.grid[r][col].dots = 1

        for c in range(GRID_COLS):
            if c != col and not isinstance(self.grid[row][c], HQCell):
                start_pos = (col * CELL_SIZE + CELL_SIZE // 2, row * CELL_SIZE + CELL_SIZE // 2)
                end_pos = (c * CELL_SIZE + CELL_SIZE // 2, row * CELL_SIZE + CELL_SIZE // 2)
                moving_blobs.append(MovingBlob(start_pos, end_pos, color, time.time(), duration=0.5))
                self.grid[row][c].color = color
                self.grid[row][c].dots = 1
        
        return moving_blobs
    
    def is_valid_move(self, row: int, col: int) -> bool:
        if not (0 <= row < GRID_ROWS and 0 <= col < GRID_COLS):
            return False
            
        # Can't place on HQ cells
        if (row, col) in [RED_HQ_POS, BLUE_HQ_POS]:
            return False
            
        # First two turns special rules
        if self.turns_played < 2:
            if self.current_player == RED:
                return row == 1  # Can only place in row 1
            else:
                return row == GRID_ROWS - 2  # Can only place in second-to-last row
        
        # If the cell already has your color, you can always add to it
        if not self.grid[row][col].is_empty() and self.grid[row][col].color == self.current_player:
            return True
        
        # For empty cells, must have a neighboring dot of same color (including diagonal)
        # or be next to your own HQ
        has_neighbor = False
        for n_row, n_col in self.get_all_neighbors(row, col):
            cell = self.grid[n_row][n_col]
            if not cell.is_empty() and cell.color == self.current_player:
                has_neighbor = True
                break
            # Check if next to own HQ
            if (self.current_player == RED and (n_row, n_col) == RED_HQ_POS) or \
               (self.current_player == BLUE and (n_row, n_col) == BLUE_HQ_POS):
                has_neighbor = True
                break
                
        return self.grid[row][col].is_empty() and has_neighbor
    
    def get_critical_mass(self, row: int, col: int) -> int:
        if (row in [0, GRID_ROWS-1]) and (col in [0, GRID_COLS-1]):
            return 2
        if row in [0, GRID_ROWS-1] or col in [0, GRID_COLS-1]:
            return 3
        return 4
    
    def is_near_critical(self, row: int, col: int) -> bool:
        if self.grid[row][col].is_empty():
            return False
        return self.grid[row][col].dots == self.get_critical_mass(row, col) - 1
    
    def get_neighbors(self, row: int, col: int) -> List[Tuple[int, int]]:
        neighbors = []
        for dr, dc in [(0, 1), (1, 0), (0, -1), (-1, 0)]:
            new_row, new_col = row + dr, col + dc
            if 0 <= new_row < GRID_ROWS and 0 <= new_col < GRID_COLS:
                neighbors.append((new_row, new_col))
        return neighbors
    
    def add_dot_to_cell(self, row, col, color):
        # Skip if it's an HQ cell
        if isinstance(self.grid[row][col], HQCell):
            # Reduce HQ health if enemy color hits it
            if ((row, col) == RED_HQ_POS and color == BLUE):
                self.red_hq_health -= 1
                return False
            elif ((row, col) == BLUE_HQ_POS and color == RED):
                self.blue_hq_health -= 1
                return False
            return False
        
        self.grid[row][col].color = color
        self.grid[row][col].dots += 1
        return self.grid[row][col].dots >= self.get_critical_mass(row, col)

    def remove_dots_from_cell(self, row, col):
        dots = self.grid[row][col].dots
        color = self.grid[row][col].color
        self.grid[row][col].clear()
        return dots, color

    def chain_reaction(self, row: int, col: int):
        if self.grid[row][col].dots >= self.get_critical_mass(row, col):
            color = self.grid[row][col].color
            self.grid[row][col].clear()
            
            # Get orthogonal neighbors only for explosions
            for neighbor_row, neighbor_col in self.get_neighbors(row, col):
                # Check if neighbor is an HQ and reduce health
                if ((neighbor_row, neighbor_col) == RED_HQ_POS and color == BLUE):
                    self.red_hq_health -= 1
                elif ((neighbor_row, neighbor_col) == BLUE_HQ_POS and color == RED):
                    self.blue_hq_health -= 1
                # For non-HQ cells, add dots
                elif not isinstance(self.grid[neighbor_row][neighbor_col], HQCell):
                    self.grid[neighbor_row][neighbor_col].color = color
                    self.grid[neighbor_row][neighbor_col].dots += 1
                    self.chain_reaction(neighbor_row, neighbor_col)
    
    def make_move(self, row: int, col: int):
        if self.game_over or not self.is_valid_move(row, col):
            return False
        
        self.grid[row][col].add_dot(self.current_player)
        self.chain_reaction(row, col)
        self.turns_played += 1
        
        powerup = next((p for p in self.powerups if p.row == row and p.col == col and p.active), None)
        moving_blobs = []
        
        if powerup:
            if powerup.type == PowerupType.STAR:
                moving_blobs = self.activate_star_powerup(row, col, self.current_player)
            elif powerup.type == PowerupType.SQUARE:
                self.dot_factories.append(DotFactory(row, col, self.current_player))
            powerup.active = False
            self.powerups = [p for p in self.powerups if p.active]
        
        self.grid[row][col].add_dot(self.current_player)
        
        # Handle dot factory effects
        for factory in self.dot_factories:
            if factory.color == self.current_player:
                neighbors = self.get_neighbors(factory.row, factory.col)
                valid_neighbors = [(r, c) for r, c in neighbors 
                                 if not isinstance(self.grid[r][c], HQCell)]
                if valid_neighbors:
                    target_row, target_col = random.choice(valid_neighbors)
                    self.grid[target_row][target_col].add_dot(self.current_player)
                    self.chain_reaction(target_row, target_col)
        
        self.chain_reaction(row, col)
        self.turns_played += 1
        self.turns_until_powerup -= 1
        if self.turns_until_powerup <= 0:
            self.spawn_powerup()
        
        if self.check_winner():
            self.game_over = True
            self.winner = self.current_player
        else:
            self.current_player = BLUE if self.current_player == RED else RED
        
    
        # Handle powerup spawning
        self.turns_until_powerup -= 1
        if self.turns_until_powerup <= 0:
            self.spawn_powerup()
            print("done")
        
        if self.turns_played > 1 and self.check_winner():
            self.game_over = True
            self.winner = self.current_player
        else:
            self.current_player = BLUE if self.current_player == RED else RED
        return True
        
    def check_winner(self) -> bool:
        if self.red_hq_health <= 0:
            self.winner = BLUE
            return True
        if self.blue_hq_health <= 0:
            self.winner = RED
            return True
        return False
    
    def get_all_dots(self) -> List[Tuple[int, int]]:
        dots = []
        for row in range(GRID_ROWS):
            for col in range(GRID_COLS):
                if not self.grid[row][col].is_empty():
                    dots.append((row, col))
        return dots

def draw_dot_pattern(window, cell, center_x, center_y, shake_offset_x=0, shake_offset_y=0):
    dot_positions = []
    
    if cell.dots == 1:
        dot_positions = [(0, 0)]
    elif cell.dots == 2:
        dot_positions = [(-1.5, 0), (1.5, 0)]
    elif cell.dots == 3:
        dot_positions = [
            (0, -1.5),  # Top
            (-1.5, 1),  # Bottom left
            (1.5, 1)   # Bottom right
        ]
    
    for dx, dy in dot_positions:
        x = center_x + dx * DOT_RADIUS + shake_offset_x
        y = center_y + dy * DOT_RADIUS + shake_offset_y
        pygame.draw.circle(window, cell.color, (int(x), int(y)), DOT_RADIUS)

def draw_game(game: Game):
    # Fill background with winner's color if game is over, otherwise current player's color
    if game.game_over:
        pastel_color = PASTEL_RED if game.winner == RED else PASTEL_BLUE
        winner_text_color = RED if game.winner == RED else BLUE
    else:
        pastel_color = PASTEL_RED if game.current_player == RED else PASTEL_BLUE
    WINDOW.fill(pastel_color)

    current_time = time.time()
    
    # Draw grid
    for row in range(GRID_ROWS):
        for col in range(GRID_COLS):
            x = col * CELL_SIZE
            y = row * CELL_SIZE
            pygame.draw.rect(WINDOW, GRAY, (x, y, CELL_SIZE, CELL_SIZE), 1)
    
    # Draw dots
    for row in range(GRID_ROWS):
        for col in range(GRID_COLS):
            cell = game.grid[row][col]
            if not cell.is_empty():
                center_x = col * CELL_SIZE + CELL_SIZE // 2
                center_y = row * CELL_SIZE + CELL_SIZE // 2
                
                # Add shaking effect for cells near critical mass
                shake_offset_x = shake_offset_y = 0
                if game.is_near_critical(row, col):
                    shake_offset_x = math.sin(current_time * SHAKE_SPEED) * SHAKE_AMPLITUDE
                    shake_offset_y = math.cos(current_time * SHAKE_SPEED) * SHAKE_AMPLITUDE
                
                draw_dot_pattern(WINDOW, cell, center_x, center_y, shake_offset_x, shake_offset_y)
    
    
    # Draw winner text if game is over
    if game.game_over:
        font = pygame.font.Font(None, 74)
        winner_color = "Punane" if game.winner == RED else "Sinine"
        text = font.render(f"{winner_color} võitis!", True, winner_text_color)
        text_rect = text.get_rect(center=(WINDOW_WIDTH//2, WINDOW_HEIGHT//2 - 50))
        WINDOW.blit(text, text_rect)

    # Draw HQs
    for (row, col), color, health in [
        (RED_HQ_POS, RED, game.red_hq_health),
        (BLUE_HQ_POS, BLUE, game.blue_hq_health)
    ]:
        x = col * CELL_SIZE
        y = row * CELL_SIZE
        pygame.draw.rect(WINDOW, color, (x, y, CELL_SIZE, CELL_SIZE))
        
        # Draw health number
        font = pygame.font.Font(None, 36)
        text = font.render(str(health), True, BLACK)
        text_rect = text.get_rect(center=(x + CELL_SIZE//2, y + CELL_SIZE//2))
        WINDOW.blit(text, text_rect)
    for powerup in game.powerups:
        if not powerup.active:
            continue
            
        center_x = powerup.col * CELL_SIZE + CELL_SIZE // 2
        center_y = powerup.row * CELL_SIZE + CELL_SIZE // 2
        
        if powerup.type == PowerupType.STAR:
            powerup.angle += STAR_SPIN_SPEED
            draw_star(WINDOW, center_x, center_y, CELL_SIZE // 3, powerup.angle)
        else:
            powerup.angle += SQUARE_SPIN_SPEED
            draw_square(WINDOW, center_x, center_y, CELL_SIZE // 3, powerup.angle)
    
    # Draw dot factories
    for factory in game.dot_factories:
        center_x = factory.col * CELL_SIZE + CELL_SIZE // 2
        center_y = factory.row * CELL_SIZE + CELL_SIZE // 2
        factory.angle += SQUARE_SPIN_SPEED
        draw_factory(WINDOW, center_x, center_y, CELL_SIZE // 3, factory.angle, factory.color)

    pygame.display.flip()
def draw_star(surface, x, y, size, angle):
    points = []
    for i in range(5):
        # Outer points
        angle_rad = math.radians(angle + i * 72)
        points.append((
            x + size * math.cos(angle_rad),
            y + size * math.sin(angle_rad)
        ))
        # Inner points
        angle_rad = math.radians(angle + 36 + i * 72)
        points.append((
            x + size * 0.4 * math.cos(angle_rad),
            y + size * 0.4 * math.sin(angle_rad)
        ))
    pygame.draw.polygon(surface, (255, 215, 0), points)  # Gold color

def draw_square(surface, x, y, size, angle):
    points = []
    for i in range(4):
        angle_rad = math.radians(angle + i * 90)
        points.append((
            x + size * math.cos(angle_rad),
            y + size * math.sin(angle_rad)
        ))
    pygame.draw.polygon(surface, (255, 165, 0), points)  # Orange color

def draw_factory(surface, x, y, size, angle, color):
    # Draw base square
    draw_square(surface, x, y, size, angle)
    # Draw inner gear
    for i in range(8):
        angle_rad = math.radians(angle + i * 45)
        start_x = x + size * 0.5 * math.cos(angle_rad)
        start_y = y + size * 0.5 * math.sin(angle_rad)
        end_x = x + size * 0.8 * math.cos(angle_rad)
        end_y = y + size * 0.8 * math.sin(angle_rad)
        pygame.draw.line(surface, color, (start_x, start_y), (end_x, end_y), 3)

class MovingBlob:
    def __init__(self, start_pos, end_pos, color, start_time, duration=0.3):
        self.start_pos = start_pos
        self.end_pos = end_pos
        self.color = color
        self.start_time = start_time
        self.duration = duration
        self.current_pos = start_pos # current position of the blob lol

    def update_position(self, current_time):
        elapsed_time = current_time - self.start_time
        if elapsed_time >= self.duration:
            self.current_pos = self.end_pos
            return True  # Animation complete
        t = elapsed_time / self.duration
        self.current_pos = (
            self.start_pos[0] + t * (self.end_pos[0] - self.start_pos[0]),
            self.start_pos[1] + t * (self.end_pos[1] - self.start_pos[1])
        )
        return False  # Animation ongoing

def draw_moving_blobs(window, moving_blobs):
    for blob in moving_blobs:
        pygame.draw.circle(window, blob.color, (int(blob.current_pos[0]), int(blob.current_pos[1])), DOT_RADIUS)

def chain_reaction(game, row, col, moving_blobs):
    if game.grid[row][col].dots >= game.get_critical_mass(row, col):
        dots, color = game.remove_dots_from_cell(row, col)
        
        # Create a blob for each dot that needs to move
        for neighbor_row, neighbor_col in game.get_neighbors(row, col):
            start_pos = (col * CELL_SIZE + CELL_SIZE // 2, row * CELL_SIZE + CELL_SIZE // 2)
            end_pos = (neighbor_col * CELL_SIZE + CELL_SIZE // 2, neighbor_row * CELL_SIZE + CELL_SIZE // 2)
            moving_blobs.append(MovingBlob(start_pos, end_pos, color, time.time()))

def update_game(game, moving_blobs):
    if game.turns_played == 0:
        return

    current_time = time.time()
    completed_blobs = []
    cells_to_check = set()
    
    # Check for winner before processing animations
    if not game.game_over and game.check_winner():
        game.game_over = True
        # The winner is the current player's opponent since they made the last successful move
        game.winner = RED if game.current_player == BLUE else BLUE
    
    # Continue with animations even if game is over
    for blob in moving_blobs:
        if blob.update_position(current_time):
            completed_blobs.append(blob)
            col = int(blob.end_pos[0] // CELL_SIZE)
            row = int(blob.end_pos[1] // CELL_SIZE)
            if game.add_dot_to_cell(row, col, blob.color):
                cells_to_check.add((row, col))
    
    for blob in completed_blobs:
        moving_blobs.remove(blob)
    
    for row, col in cells_to_check:
        chain_reaction(game, row, col, moving_blobs)

def make_move(game, row, col, moving_blobs):
    if game.game_over or not game.is_valid_move(row, col) or moving_blobs:
        return False
    
    # Add dot to the selected cell
    if game.add_dot_to_cell(row, col, game.current_player):
        chain_reaction(game, row, col, moving_blobs)
    
    game.turns_played += 1
    # Change turns immediately after a successful move
    game.current_player = BLUE if game.current_player == RED else RED
    return True

def main():
    game = Game()
    clock = pygame.time.Clock()
    moving_blobs = []
    
    while True:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            
            if event.type == pygame.MOUSEBUTTONDOWN and not game.game_over:
                mouse_x, mouse_y = pygame.mouse.get_pos()
                col = mouse_x // CELL_SIZE
                row = mouse_y // CELL_SIZE
                make_move(game, row, col, moving_blobs)
            
            if event.type == pygame.KEYDOWN and event.key == pygame.K_r:
                game = Game()
                moving_blobs.clear()
        
        update_game(game, moving_blobs)
        draw_game(game)
        draw_moving_blobs(WINDOW, moving_blobs)
        pygame.display.flip()
        clock.tick(60)

if __name__ == "__main__":
    main()
